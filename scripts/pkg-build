#!/bin/sh
#
# Script to build a single package.  Based on pbulk's pkg-build.
#
# This script receives the ScanIndex entries for the package in question on
# stdin.
#

set -e

# Required core variables.
: ${bob_bulklog:?}
: ${bob_make:?}
: ${bob_packages:?}
: ${bob_pkgtools:?}
: ${bob_pkgsrc:?}
: ${bob_prefix:?}
: ${bob_status_fd:?}
: ${bob_tar:?}

# Optional file descriptor for real-time output to UI
bob_output_fd=${bob_output_fd:-}

# Run a command, logging output to file and optionally to the output fd for
# live status in the UI.
run_log() {
	logfile="$1"
	shift
	if [ -n "${bob_output_fd}" ]; then
		status_file="/tmp/.bob_status.$$"
		{ set +x; "$@" 2>&1; echo $? > "${status_file}"; } | \
		    tee -a "${logfile}" >&${bob_output_fd}
		status=$(cat "${status_file}")
		rm -f "${status_file}"
		return ${status}
	else
		"$@" >> "${logfile}" 2>&1
	fi
}

cleanup() {
	if [ -n "${KEEP_WRKDIR}" ]; then
		${bob_make} pbulk-save-wrkdir \
		    INTO="${pkglogdir}/wrkdir.tar.gz" \
		    TAR="${bob_tar}" 2>&1 || true
	fi
	if [ -n "${KEEP_PREFIX}" ] && [ -f "${pkglogdir}/install.log" ]; then
		${bob_tar} -czf "${pkglogdir}/prefix.tar.gz" \
		    ${bob_prefix} 2>&1 || true
	fi
	#
	# Don't run make clean if SKIP_CLEAN is set, this is so bob can handle
	# save_wrkdir_patterns first before cleaning up itself.
	#
	if [ -z "${SKIP_CLEAN}" ]; then
		${bob_make} clean > /dev/null 2>&1 || true
	fi
	exit 1
}

run_direct() { "$@"; }
run_su() { su "${bob_build_user}" -c '"$@"' make "$@"; }

run_make() {
	run_cmd=$1
	shift
	${run_cmd} ${bob_make} "$@" \
		BATCH=1 \
		DEPENDS_TARGET=/nonexistent \
		${MAKE_FLAGS} \
		WRKLOG="${pkglogdir}/work.log"
}

run_usergroup() {
	case "${usergroup_phase}" in
	*configure)
		[ "$1" != "configure" ] || ${bob_make} create-usergroup clean
		;;
	*build)
		[ "$1" != "build" ] || ${bob_make} create-usergroup
		;;
	pre-install)
		[ "$1" != "install" ] || ${bob_make} create-usergroup
		;;
	esac
}

# Write current stage to .stage file and status fd for reporting
set_stage() {
	echo "$1" > "${pkglogdir}/.stage"
	echo "stage:$1" >&${bob_status_fd}
}

# Send a status message to the master process
send_status() {
	echo "$1" >&${bob_status_fd}
}

#
# Script starts here.  Parse ScanIndex from stdin.
#
while read scan_input; do
	case "${scan_input}" in
	PKGNAME=*)
		pkgname=${scan_input#PKGNAME=}
		;;
	PKG_LOCATION=*)
		pkgdir=${scan_input#PKG_LOCATION=}
		;;
	DEPENDS=*)
		dependencies=${scan_input#DEPENDS=}
		;;
	MULTI_VERSION=*)
		MAKE_FLAGS=${scan_input#MULTI_VERSION=}
		;;
	BOOTSTRAP_PKG=*)
		is_bootstrap=${scan_input#BOOTSTRAP_PKG=}
		;;
	USERGROUP_PHASE=*)
		usergroup_phase=${scan_input#USERGROUP_PHASE=}
	esac
done

pkglogdir="${bob_bulklog}/${pkgname}"

if [ -z "${bob_build_user}" ]; then
	run_checksum=run_direct
	run_build=run_direct
	run_install=run_direct
else
	run_checksum=run_direct
	run_build=run_su
	run_install=run_su
fi

pkg_up_to_date="$(dirname "$0")/pkg-up-to-date"
if [ -x ${pkg_up_to_date} ]; then
	mkdir -p ${pkglogdir}
	if ${pkg_up_to_date} ${pkgname} ${dependencies} \
	    > ${pkglogdir}/up-to-date.log 2>&1; then
		rm -rf ${pkglogdir}
		send_status "skipped"
		exit 0
	fi
fi

cd ${bob_pkgsrc}/${pkgdir}

mkdir -p "${pkglogdir}"
rm -f "${pkglogdir}"/.stage

# Set up output redirection
exec >${pkglogdir}/pkg-build.log 2>&1
set -x

# Create work.log and make it writable by the unprivileged user
touch "${pkglogdir}/work.log"
if [ -n "${bob_build_user}" ]; then
	chown "${bob_build_user}" "${pkglogdir}/work.log"
fi

trap cleanup INT TERM

set_stage "pre-clean"
run_log "${pkglogdir}/pre-clean.log" ${bob_make} clean

# Install dependencies
if [ -n "${dependencies}" ]; then
	set_stage "depends"
	run_log "${pkglogdir}/depends.log" \
	    env PKG_PATH="${bob_packages}/All" \
	    ${bob_pkgtools}/pkg_add ${dependencies} || cleanup
fi

set_stage "checksum"
run_log "${pkglogdir}/checksum.log" run_make ${run_checksum} checksum || cleanup

set_stage "configure"
run_log "${pkglogdir}/configure.log" run_usergroup configure || cleanup
run_log "${pkglogdir}/configure.log" run_make ${run_build} configure || cleanup

set_stage "build"
run_log "${pkglogdir}/build.log" run_usergroup build || cleanup
run_log "${pkglogdir}/build.log" run_make ${run_build} all || cleanup

set_stage "install"
run_log "${pkglogdir}/install.log" run_usergroup install || cleanup
run_log "${pkglogdir}/install.log" run_make ${run_install} stage-install || cleanup

set_stage "package"
run_log "${pkglogdir}/package.log" run_make run_direct stage-package-create || cleanup

pkgfile=$(run_make run_direct show-var VARNAME=STAGE_PKGFILE)

# Test package install unless this is a bootstrap package as it will likely
# already be installed.
if [ -z "${is_bootstrap}" ]; then
	run_log "${pkglogdir}/package.log" \
	    ${bob_pkgtools}/pkg_add ${pkgfile} || cleanup
fi

# Test package uninstall unless bootstrap package (will have preserve flag set).
if [ -z "${is_bootstrap}" ]; then
	set_stage "deinstall"
	run_log "${pkglogdir}/deinstall.log" \
	    ${bob_pkgtools}/pkg_delete ${pkgname} || cleanup
fi

# Save package.
mkdir -p "${bob_packages}/All"
cp "${pkgfile}" "${bob_packages}/All/"

set_stage "clean"
run_log "${pkglogdir}/clean.log" ${bob_make} clean || true

# Remove package bulklog directory on success
rm -rf "${pkglogdir}"

exit 0
